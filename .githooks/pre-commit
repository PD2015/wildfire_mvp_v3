#!/bin/bash
# Pre-commit hook to auto-format, analyze, and check for API keys
# This ensures all commits have properly formatted code and no secrets
#
# Setup: git config core.hooksPath .githooks
# Bypass: git commit --no-verify (not recommended)

echo "üîç Running dart format..."

# Format all Dart files
dart format .

# Add any formatted files back to the staging area
git add -u

echo "‚úÖ Code formatting complete"
echo ""
echo "üîç Running flutter analyze..."

# Run static analysis (only if Flutter is available)
if command -v flutter >/dev/null 2>&1; then
  # Get list of staged Dart files (excluding deleted files)
  STAGED_DART_FILES=$(git diff --cached --name-only --diff-filter=ACM | grep '\.dart$' || true)

  if [ -n "$STAGED_DART_FILES" ]; then
    # Clean any stale build artifacts that might cause version detection issues
    flutter clean > /dev/null 2>&1 || true

    # Run analyze with better error handling for worktrees
    flutter analyze --no-fatal-infos $STAGED_DART_FILES 2>&1 | tee /tmp/flutter_analyze_output.txt
    ANALYZE_EXIT=${PIPESTATUS[0]}

    # Check for known worktree/version detection issues
    if grep -q "version is 0.0.0-unknown" /tmp/flutter_analyze_output.txt; then
      echo ""
      echo "‚ö†Ô∏è  Flutter SDK version detection issue (common in worktrees)"
      echo "   Falling back to dart analyze on staged files..."

      # Fallback to dart analyze which doesn't have the same issue
      # Only analyze staged Dart files to avoid errors in uncommitted work
      dart analyze --fatal-warnings $STAGED_DART_FILES
      ANALYZE_EXIT=$?
    fi

    if [ $ANALYZE_EXIT -ne 0 ]; then
      echo ""
      echo "‚ùå Static analysis found issues in staged files!"
      echo "   Please fix the issues above before committing."
      echo "   Or use 'git commit --no-verify' to bypass (not recommended)."
      exit 1
    fi

    echo "‚úÖ Static analysis passed for staged files"
  else
    echo "‚ÑπÔ∏è  No Dart files staged for commit"
  fi
else
  echo "‚ö†Ô∏è  Flutter not found in PATH, skipping analyze (CI will catch issues)"
fi

echo ""
echo "üîç Checking for secrets with gitleaks..."

# Check if gitleaks is installed
if command -v gitleaks >/dev/null 2>&1; then
  # Run gitleaks on staged files only
  # --staged flag scans only the files in the git staging area
  # --redact hides the actual secret values in output
  # -v shows verbose output
  gitleaks protect --staged --redact -v
  GITLEAKS_EXIT=$?

  if [ $GITLEAKS_EXIT -ne 0 ]; then
    echo ""
    echo "‚ùå Gitleaks found secrets in staged files!"
    echo ""
    echo "Common fixes:"
    echo "  ‚Ä¢ Move secrets to: env/dev.env.json (git-ignored)"
    echo "  ‚Ä¢ Use placeholders in docs: YOUR_API_KEY_HERE"
    echo "  ‚Ä¢ Add to .gitleaksignore if false positive"
    echo ""
    echo "See: docs/API_KEY_SETUP.md"
    echo ""
    echo "To bypass (if false positive): git commit --no-verify"
    exit 1
  fi

  echo "‚úÖ No secrets detected by gitleaks"
else
  echo "‚ö†Ô∏è  Gitleaks not installed, using basic pattern matching..."
  echo "   Install: brew install gitleaks"
  echo ""

  # Fallback to basic pattern matching if gitleaks not available
  STAGED_FILES=$(git diff --cached --name-only)

  if [ -z "$STAGED_FILES" ]; then
    echo "‚úÖ No files staged"
    exit 0
  fi

  # Check for Google Maps API keys
  # Get all occurrences with 2 lines of context before
  FOUND_KEYS_RAW=$(echo "$STAGED_FILES" | xargs grep -B2 -n -E "AIzaSy[0-9A-Za-z_-]{33}" 2>/dev/null || true)

  if [ -n "$FOUND_KEYS_RAW" ]; then
    # Process each group of context lines (separated by --)
    # If the group contains PLACEHOLDER, YOUR_*_KEY, example., or XXX, it's safe
    UNSAFE_KEYS=""

    # Split by -- separator and check each block
    echo "$FOUND_KEYS_RAW" | awk '
      BEGIN { RS="--"; block="" }
      {
        if (NF > 0) {
          block = $0
          # Check if block contains API key pattern
          if (block ~ /AIzaSy[0-9A-Za-z_-]{33}/) {
            # Check if block has safe markers
            if (block !~ /PLACEHOLDER|YOUR_.*_KEY|example\.|gitleaks:allow|XXX/) {
              print block
            }
          }
        }
      }
    ' > /tmp/unsafe_keys.txt

    UNSAFE_KEYS=$(cat /tmp/unsafe_keys.txt)

    if [ -n "$UNSAFE_KEYS" ]; then
      echo ""
      echo "‚ùå ERROR: Google Maps API key detected!"
      echo ""
      echo "$UNSAFE_KEYS"
      echo ""
      echo "API keys must be in git-ignored files:"
      echo "  - env/dev.env.json (local development)"
      echo "  - android/local.properties (Android builds)"
      echo "  - GitHub Secrets (CI/CD)"
      echo ""
      echo "To mark as safe placeholder:"
      echo "  - Add XML comment with 'PLACEHOLDER' above the key"
      echo "  - Or add inline comment: # gitleaks:allow"
      echo ""
      echo "See: docs/guides/setup/google-maps.md"
      echo ""
      echo "To bypass (if false positive): git commit --no-verify"
      exit 1
    fi
  fi

  # Check for secret files that should be git-ignored
  if echo "$STAGED_FILES" | grep -E "^(env/dev\.env\.json|android/local\.properties)$"; then
    echo ""
    echo "‚ùå ERROR: Secret files are staged!"
    echo ""
    echo "These files should be git-ignored:"
    echo "$STAGED_FILES" | grep -E "^(env/dev\.env\.json|android/local\.properties)$" | sed 's/^/  - /'
    echo ""
    echo "To unstage: git reset HEAD <file>"
    exit 1
  fi

  # Check for AWS keys
  if echo "$STAGED_FILES" | xargs grep -l -E "(AKIA|ASIA)[0-9A-Z]{16}" 2>/dev/null; then
    echo ""
    echo "‚ùå ERROR: AWS access key detected!"
    echo ""
    echo "To bypass (if false positive): git commit --no-verify"
    exit 1
  fi

  # Check for GitHub tokens
  if echo "$STAGED_FILES" | xargs grep -l -E "(ghp_|gho_|ghu_|ghs_|ghr_)[0-9A-Za-z]{36,255}" 2>/dev/null; then
    echo ""
    echo "‚ùå ERROR: GitHub token detected!"
    echo ""
    echo "To bypass (if false positive): git commit --no-verify"
    exit 1
  fi

  echo "‚úÖ No secrets detected (basic scan)"
fi

exit 0
